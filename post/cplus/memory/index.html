
<!DOCTYPE html>
<html lang="en-us">
<head>

  
  <meta charset="UTF-8">
  <title>
    memory | Learn and record
  </title>


  
  <meta name="viewport" content="width=device-width,user-scalable=no,maximum-scale=1,initial-scale=1">

  
  <link rel="canonical" href="http://cherishzhang.github.io/post/cplus/memory/"/>

  
  <link rel="stylesheet" href="/css/sanitize.css">
  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/highlight_monokai.css">
  <link rel="stylesheet" href="/css/theme.css">
  <link rel="stylesheet" href="/css/custom.css">

  
  <link href="http://cherishzhang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Learn and record" />
  <link href="http://cherishzhang.github.io/index.xml" rel="feed" type="application/rss+xml" title="Learn and record" />

  
  
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
</head>



<body>
<div class="container">

  
  <header role="banner">
    <div class="row gutters">
      <div id="site-title" class="col span_6">
        <h1><a href="http://cherishzhang.github.io/">Learn and record</a></h1>
        
      </div>
      <div id="social" class="col span_6">
        <ul>
          <li><a href="http://cherishzhang.github.io/about" target="_blank">About me</a></li>
          <li><a href="https://github.com/Cherishzhang" target="_blank">GitHub</a></li>
          <li><a href="cherishzhang920508@gmail.com" target="_blank">Email</a></li>
        </ul>
      </div>
  </header>


  
  <main id="single" role="main">
    <div class="article-header">
      <h1>memory</h1>
      <div class="meta">
        Aug 24, 2016 &nbsp;
        
      </div>
    </div>
    <article>
      

<h2 id="内存分类:3f22e6e4723e5cb8755f0a1430a9a54d">内存分类</h2>

<p>程序占用的内存分为以下几类：</p>

<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>静态存储区域</td>
<td>编译时已分配好，如全局变量，static变量，程序运行期间都存在，其中初始化的全局/静态变量在一块区域，未初始化的在相邻的另一块区域</td>
</tr>

<tr>
<td>栈(stack)</td>
<td>大小在编译后确定，后进先出，自动释放。效率高但容量有限。</td>
</tr>

<tr>
<td>堆(heap)</td>
<td>动态分配，手动释放</td>
</tr>

<tr>
<td>文字常量区</td>
<td>存放常量字符串</td>
</tr>

<tr>
<td>程序代码区</td>
<td>存放函数体的二进制代码</td>
</tr>
</tbody>
</table>

<p><strong><r>堆栈的区别</r></strong>:栈是静态，而堆是动态的；栈内存系统自动回收，而堆分配的内存，需手动显式回收。<r>malloc</r>,<r>new</r>分配的内存是在<r>堆</r>上，程序结束前需用free,delete回收。</p>

<pre><code>int a = 0; //全局初始化区
char *p1; //全局未初始区
void main()
{
  int b; //栈
  char s[] = &quot;abc&quot;; //栈，运行时赋值
  char *p2; // 栈
  char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上，编译时确定
  static int c = 0; //全局(静态)初始化区
  p1 = (char *)malloc(10); //p1指向堆区
}
</code></pre>

<p><strong>虚拟内存/交换空间</strong></p>

<p>一种内存管理的技术，将实际上多个被分隔的<r>物理内存碎片</r>和磁盘存储器上的部分空间虚拟成<r>一段连续完整的地址空间</r>。编制程序时使用的地址称为<r>虚地址</r>或逻辑地址，而计算机物理内存的访问地址则称为<r>实地址</r>或物理地址。这里面涉及到调度算法，替换策略，更新策略等。</p>

<h2 id="几个函数:3f22e6e4723e5cb8755f0a1430a9a54d">几个函数</h2>

<h3 id="malloc-memory-allocation:3f22e6e4723e5cb8755f0a1430a9a54d">malloc(memory allocation)</h3>

<p>函数原型：void *malloc(size_t num_bytes); <r>动态分配内存</r>，头文件stdlib.h。</p>

<p>功能：分配长度为num_bytes字节的内存块，返回值是一个指向内存起始地址的指针。</p>

<p>工作机制：它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。</p>

<p>Linux Libc6采用的机制是在free的时候试图整合相邻的碎片，使其合并成为一个较大的free空间。</p>

<h3 id="calloc-clear-allocation:3f22e6e4723e5cb8755f0a1430a9a54d">calloc(clear allocation)</h3>

<p>函数原型： void *calloc(size_t n, size_t size); <r>动态内存分配并清零</r>，头文件stdlib.h或malloc.h。 使用后用<r>free(起始地址的指针)</r>对内存进行释放。</p>

<p>功能： 在内存的<r>动态存储区</r>中分配n个长度为size的连续空间，函数返回一个指向分配<r>起始地址</r>的指针；如果分配不成功，返回<r>NULL</r>。</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main(){
	char *str = NULL;
	str = (char*)calloc(10, sizeof(char)); //分配内存空间
	strcpy(str,&quot;hello&quot;);
	printf(&quot;String is %s\n&quot;, str);
	free(str); //释放空间
	return 0;
}
</code></pre>

<h3 id="realloc:3f22e6e4723e5cb8755f0a1430a9a54d">realloc</h3>

<p>函数原型： extern void *realloc(void *mem_address, unsigned int newsize);</p>

<p>语法：指针名 = (数据类型*) realloc(要改变内存大小的指针名，新的大小)</p>

<p>头文件：stdlib.h(malloc.h)</p>

<p>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。</p>

<h3 id="posix-memalign:3f22e6e4723e5cb8755f0a1430a9a54d">posix_memalign</h3>

<p>数据的对齐是指<strong>数据的地址和由硬件决定的内存块大小之间的关系</strong>，一个变量的地址是变量本身大小的倍数时，称为<r>自然对齐</r>。比如一个32bit的变量，大小是4个字节，自然对齐的情况下，地址应该是4的倍数(一个地址对应一个字节)。不对齐的数据载入可能会引起<r>性能的下降</r>或<r>进程的陷入</r>。</p>

<p>malloc,calloc,realloc返回的地址对于任何的C类型都是对齐的，在32位系统以8字节为边界对齐，在64位系统以16字节为边界对齐。但对于更大的边界，如<r>页面</r>，需要动态对齐。</p>

<p>函数原型：int posix_memalign(void **memptr, size_t alignment, size_t size);</p>

<p>分配长度为size的连续空间，地址以alignment为边界对齐，memptr保存返回的内存块地址。 成功时返回0，失败时，memptr没有被定义，错误码：<r>EINVAL</r>(alignment不是2的幂，或不是void指针的倍数),<r>ENOMEM</r>(没有足够内存),</p>

<pre><code>char *buf;
int ret;
ret = posix_memalign(&amp;buf, 256, 1024);
if(ret){
	fprintf(stderr, &quot;posix_memalign:%s\n&quot;,strerror(ret));
	return -1;
}
free(buf); //释放内存
</code></pre>

<h2 id="参考链接:3f22e6e4723e5cb8755f0a1430a9a54d">参考链接</h2>

<p><a href="http://baike.baidu.com/link?url=ji8HkIlHG_7AgV_CVHw4Y3NJfzpaTlOICcfMOdI3R8fGKnCE5RzgL9YBCqSyUP3TF652tW-wVvNHFad1lp7LNq">虚拟内存</a></p>

<p><a href="http://blog.jobbole.com/75656/">如何实现一个malloc</a></p>


      
      
    </article>
    
 <aside><div id="disqus_thread"></div></aside>

<script type="text/javascript">
     
    var disqus_shortname = 'http-cherishzhang-github-io';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>



  </main>

  <nav class="pagination-single">
    
      <span class="previous">&larr; <a href="http://cherishzhang.github.io/post/spark/" rel="prev">Spark开发学习</a></span>
    
    
  </nav>


  
  <footer role="contentinfo">
    <div style="text-align:center;">
      <img src="/images/avatar.jpg" width="64" height="64"><br>
      
    </div>
  </footer>


</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



</body>
</html>

